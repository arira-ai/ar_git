# Git Branching and Merging Strategy

## Objective

This chapter explains:

* Why branches exist
* How branching works internally
* Common branching strategies
* How merging works
* Hands-on commands with real workflow
* How teams use branches in real projects

---

## 1. What is a Branch in Git?

### Definition

A **branch** in Git is a **movable pointer** to a commit.

* Branches allow parallel development
* Changes in one branch do not affect others
* Default branch is usually `main`

---

### Why Branching is Needed

Without branches:

* Everyone works on the same code
* High risk of breaking production
* No isolation for features or fixes

With branches:

* Safe experimentation
* Parallel work
* Controlled releases

---

### Branch Concept

```mermaid

flowchart LR
    subgraph Shared_History [Linear Past]
        A((A)) --> B((B))
    end

    subgraph Divergence [Parallel Present]
        B -- "Production Fixes" --> C((C))
        B -- "New Feature" --> D((D))
    end

    subgraph Labels [Branch Pointers]
        direction TB
        Main[main]
        Feat[feature]
    end

    %% Connections to labels
    C --- Main
    D --- Feat

    %% Note as a node
    Note1["Commit 'B' is the <br/> Common Ancestor. <br/> From here, C and D <br/> do not know about <br/> each other."]
    Note1 --- B
    
    style Note1 stroke-dasharray: 5 5
    style Main font-weight:bold
    style Feat font-weight:bold
```

---

## 2. Types of Branches (Beginner to Team Level)

### 1. Main / Master Branch

* Represents stable, production-ready code
* Should always be deployable
* Direct commits are usually restricted

---

### 2. Feature Branch

* Used to develop a new feature
* Created from `main`
* Merged back after completion

Naming examples:

* `feature/login`
* `feature/payment-api`

---

### 3. Bugfix / Hotfix Branch

* Used to fix issues
* Hotfix is used for production issues

Examples:

* `bugfix/ui-alignment`
* `hotfix/security-patch`

---

## 3. Basic Branching Commands (Hands-On)

### Create a New Branch

```bash
git branch feature-login
```

---

### Switch to a Branch

```bash
git checkout feature-login
```

OR (modern command):

```bash
git switch feature-login
```

---

### Create and Switch in One Command

```bash
git checkout -b feature-login
```

---

### List Branches

```bash
git branch
```

---

### Delete a Branch (After Merge)

```bash
git branch -d feature-login
```

---

## 4. Hands-On Scenario: Feature Development

### Scenario

You want to add a **login feature** without breaking `main`.

---

### Step 1: Ensure You Are on Main

```bash
git checkout main
git pull origin main
```

---

### Step 2: Create Feature Branch

```bash
git checkout -b feature-login
```

---

### Step 3: Make Changes

```bash
echo "Login feature code" >> login.txt
git status
```

---

### Step 4: Commit Changes

```bash
git add login.txt
git commit -m "Add login feature"
```

---

### Action Flow (Feature Branch)

```mermaid

flowchart LR
    subgraph Baseline [The Source]
        A[main branch]
    end

    subgraph Isolation [The Workspace]
        B["git checkout -b <br/> 'Branch Created'"]
        C["Work on Files <br/> 'Modified State'"]
    end

    subgraph Snapshot [The Record]
        D["git commit <br/> 'Saved to History'"]
    end

    %% Flow
    A --> B
    B --> C
    C --> D

    %% Note for Students
    Note1["None of these steps <br/> affect the 'main' code <br/> until a merge happens."]
    Note1 --- C

    style B font-weight:bold
    style D font-weight:bold
```

---

## 5. Merging Branches

### What is Merge?

Merging combines changes from one branch into another.

Most common merge:

* Feature branch â†’ Main branch

---

### Step 5: Switch Back to Main

```bash
git checkout main
```

---

### Step 6: Merge Feature Branch

```bash
git merge feature-login
```

---

### Resulting Flow

```mermaid

flowchart LR
    subgraph State_1 [Step 1: Divergence]
        A1[main]
        F1[feature-login]
    end

    subgraph Action [Step 2: The Merge]
        M{git merge}
    end

    subgraph State_2 [Step 3: Convergence]
        D[main updated]
    end

    %% Flow
    A1 --> M
    F1 --> M
    M --> D

    %% Note for Students
    Note1["The 'feature-login' branch <br/> still exists locally until <br/> you manually delete it."]
    Note1 --- D

    style M stroke-width:2px,stroke-dasharray: 5 5
```

---

## 6. Merge Types (Concept Level)

### 1. Fast-Forward Merge

Occurs when:

* Main has no new commits
* Feature branch is directly ahead

```mermaid

flowchart LR
    subgraph History [Linear Timeline]
        A((Commit A)) --> B((Commit B))
    end

    subgraph Pointers [Branch Labels]
        direction TB
        Main[main]
        Feat[feature]
    end

    %% Representation of the 'Slide'
    B --- Feat
    A -. "Main moves here" .-> B
    B --- Main

    %% Styling
    style Main font-weight:bold,stroke-width:2px
    style Feat font-weight:bold,stroke-width:2px
```

---

### 2. Three-Way Merge

Occurs when:

* Both branches have new commits

```mermaid

flowchart LR
    subgraph Common_History [Past]
        A((A <br/> Base))
    end

    subgraph Diverged_Work [Parallel Work]
        B((B <br/> Main))
        C((C <br/> Feature))
    end

    subgraph Integration [Future]
        D((D <br/> Merge <br/> Commit))
    end

    %% The Relationships
    A --> B
    A --> C
    
    B --> D
    C --> D

    %% Note
    Note1["Commit 'D' has two <br/> parents. It ties the <br/> two histories together <br/> permanently."]
    Note1 --- D
    
    style Note1 stroke-dasharray: 5 5
```

---

## 7. Merge Conflicts

### What is a Merge Conflict?

Occurs when:

* Same file
* Same line
* Modified differently in both branches

---

### Conflict Example

```bash
git merge feature-login
```

Git output:

```
CONFLICT (content): Merge conflict in app.txt
```

---

### Resolving Conflict

1. Open conflicted file
2. Choose correct changes
3. Remove conflict markers
4. Commit resolution

```bash
git add app.txt
git commit -m "Resolve merge conflict"
```

---

### Conflict Resolution Flow

```mermaid

flowchart TD
    subgraph Trigger [The Event]
        A[Merge / Pull Attempt]
    end

    subgraph Detection [Git Engine]
        B{"Conflict Detected? <br/> (Same line edited)"}
    end

    subgraph Resolution [Human Intervention]
        C[Open Editor]
        D[Choose 'Current' <br/> or 'Incoming']
        E[Remove Conflict Markers <br/> <<<<<, =====, >>>>>]
    end

    subgraph Completion [Finalizing]
        F[git add]
        G[git commit]
    end

    %% Flow
    A --> B
    B -- "Yes" --> C
    C --> D
    D --> E
    E --> F
    F --> G
    
    B -- "No" --> H[Auto-Merge Successful]

    %% Note
    Note1["A conflict is not an error; <br/> it is a safety feature <br/> to prevent losing code."]
    Note1 --- B
    
    style Note1 stroke-dasharray: 5 5
```

---

## 8. Branching Strategies (Real-World)

### 1. Feature Branch Strategy (Most Common)

* One branch per feature
* Merged via Pull Request

```mermaid

flowchart LR
    subgraph Stable_Line [Production]
        A[main branch]
    end

    subgraph Feature_Work [In Progress]
        B[feature-1]
        C[feature-2]
    end

    subgraph Integration [Quality Gate]
        D{PR Merge}
        E[main branch <br/> 'Updated']
    end

    %% The Flow
    A -- "git checkout -b" --> B
    A -- "git checkout -b" --> C
    
    B -- "Diverged" --> D
    C -- "Diverged" --> D
    
    D -- "Converged" --> E

    %% Note
    Note1["Feature 1 and 2 are <br/> developed in isolation <br/> and merged back <br/> when tested."]
    Note1 --- D
    
    style Note1 stroke-dasharray: 5 5
```

Used by:

* Small teams
* Open-source projects

---

### 2. GitHub Flow (Beginner-Friendly)

Steps:

1. Create branch from `main`
2. Commit changes
3. Open Pull Request
4. Review
5. Merge to `main`

No release branches.

---

### 3. GitFlow 

Branches:

```yaml
main        # Production-ready, stable code
develop     # Integration branch for ongoing development
feature/*   # New feature development branches
release/*   # Pre-release testing and stabilization
hotfix/*    # Urgent fixes for production issues
```

Used in:

* Large teams
* Release-based products

---

## 9. Branching + Pull Request Workflow

```mermaid

flowchart LR
    subgraph Local_Work [Local Machine]
        A[1. Create Branch] --> B[2. Commit Changes]
    end

    subgraph Transport [Sync]
        B --> C[3. Push Branch]
    end

    subgraph GitHub_Interface [GitHub Cloud]
        C --> D{4. Open PR}
        D --> E[5. Review]
        E --> F((6. Merge))
    end

    %% Note for context
    Note1["Main branch is protected. <br/> Changes only enter through <br/> the PR gate."]
    Note1 --- F

    style Note1 stroke-dasharray: 5 5
```

---

## 10. Best Practices for Beginners

* Always create a branch for work
* Keep branches small and focused
* Pull latest changes before merging
* Delete branches after merge
* Never commit directly to `main`

---

## Common Beginner Mistakes

* Working directly on `main`
* Forgetting to switch branches
* Merging without pulling latest changes
* Ignoring merge conflicts

---

## Final Mental Model

* Branch = isolated workspace
* Commit = checkpoint
* Merge = combine work
* PR = controlled merge
